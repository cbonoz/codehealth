program output:b'# -*- coding: utf-8 -*-\n\nfrom __future__ import print_function\n\nimport sublime\nimport sublime_plugin\nimport os\nimport threading\nimport subprocess\nimport functools\nimport re\nfrom copy import copy\n\nIS_ST3 = sublime.version().startswith(\'3\')\n\n\ndef get_settings():\n    return sublime.load_settings("Modific.sublime-settings")\n\n\ndef get_vcs_settings():\n    """\n    Returns list of dictionaries\n    each dict. represents settings for VCS\n    """\n\n    default = [\n        {"name": "git", "dir": ".git", "cmd": "git"},\n        {"name": "svn", "dir": ".svn", "cmd": "svn"},\n        {"name": "bzr", "dir": ".bzr", "cmd": "bzr"},\n        {"name": "hg",  "dir": ".hg",  "cmd": "hg"},\n        {"name": "tf",  "dir": "$tf",  "cmd": "C:/Program Files (x86)/Microsoft Visual Studio 11.0/Common7/IDE/TF.exe"}\n    ]\n    settings = get_settings().get(\'vcs\', default)\n\n    # re-format settings array if user has old format of settings\n    if type(settings[0]) == list:\n        settings = [dict(name=name, cmd=cmd, dir=\'.\'+name) for name, cmd in settings]\n\n    return settings\n\n\ndef get_user_command(vcs_name):\n    """\n    Returns command that user specified for vcs_name\n    """\n\n    try:\n        return [vcs[\'cmd\'] for vcs in get_vcs_settings() if vcs.get(\'name\') == vcs_name][0]\n    except IndexError:\n        return None\n\n\ndef tfs_root(directory):\n    try:\n        tf_cmd = get_user_command(\'tf\') or \'tf\'\n        command = [tf_cmd, \'workfold\', directory]\n        p = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE,\n                             shell=True, universal_newlines=False)\n        out, err = p.communicate()\n        m = re.search(r"^ \\$\\S+: (\\S+)$", out, re.MULTILINE)\n        if m:\n            return {\'root\': m.group(1), \'name\': \'tf\', \'cmd\': tf_cmd}\n    except:\n        return None\n\n\ndef get_vcs(directory):\n    """\n    Determines root directory for VCS and which of VCS systems should be used for a given directory\n\n    Returns dictionary {name: .., root: .., cmd: .., dir: ..}\n    """\n\n    vcs_check = [(lambda vcs: lambda dir: os.path.exists(os.path.join(dir, vcs.get(\'dir\', False)))\n                 and vcs)(vcs) for vcs in get_vcs_settings()]\n\n    start_directory = directory\n    while directory:\n        available = list(filter(bool, [check(directory) for check in vcs_check]))\n        if available:\n            available[0][\'root\'] = directory\n            return available[0]\n\n        parent = os.path.realpath(os.path.join(directory, os.path.pardir))\n        if parent == directory:  # /.. == /\n            # try TFS as a last resort\n            # I\'m not sure why we need to do this. Seems like it should find root for TFS in the main loop\n            return tfs_root(start_directory)\n        directory = parent\n\n    return None\n\n\ndef main_thread(callback, *args, **kwargs):\n    # sublime.set_timeout gets used to send things onto the main thread\n    # most sublime.[something] calls need to be on the main thread\n    sublime.set_timeout(functools.partial(callback, *args, **kwargs), 0)\n\n\ndef _make_text_safeish(text, fallback_encoding, method=\'decode\'):\n    # The unicode decode here is because sublime converts to unicode inside\n    # insert in such a way that unknown characters will cause errors, which is\n    # distinctly non-ideal... and there\'s no way to tell what\'s coming out of\n    # git in output. So...\n    try:\n        unitext = getattr(text, method)(\'utf-8\')\n    except (UnicodeEncodeError, UnicodeDecodeError):\n        unitext = getattr(text, method)(fallback_encoding)\n    except AttributeError:\n        # strongly implies we\'re already unicode, but just in case let\'s cast\n        # to string\n        unitext = str(text)\n    return unitext\n\n\ndef do_when(conditional, callback, *args, **kwargs):\n    if conditional():\n        return callback(*args, **kwargs)\n    sublime.set_timeout(functools.partial(do_when, conditional, callback, *args, **kwargs), 50)\n\n\ndef log(*args, **kwargs):\n    """\n    @param *args: string arguments that should be logged to console\n    @param debug=True: debug log mode\n    @param settings=None: instance of sublime.Settings\n    """\n    debug = kwargs.get(\'debug\', True)\n    settings = kwargs.get(\'settings\', None)\n\n    if not settings:\n        settings = get_settings()\n\n    if debug and not settings.get(\'debug\', False):\n        return\n\n    print(\'Modific:\', *args)\n\n\nclass CommandThread(threading.Thread):\n\n    def __init__(self, command, on_done, working_dir="", fallback_encoding="", console_encoding="", **kwargs):\n        threading.Thread.__init__(self)\n        self.command = command\n        self.on_done = on_done\n        self.working_dir = working_dir\n        if \'stdin\' in kwargs:\n            self.stdin = kwargs[\'stdin\'].encode()\n        else:\n            self.stdin = None\n        self.stdout = kwargs.get(\'stdout\', subprocess.PIPE)\n        self.console_encoding = console_encoding\n        self.fallback_encoding = fallback_encoding\n        self.kwargs = kwargs\n\n    def run(self):\n        try:\n            # Per http://bugs.python.org/issue8557 shell=True is required to\n            # get $PATH on Windows. Yay portable code.\n            shell = os.name == \'nt\'\n\n            if self.working_dir != "":\n                os.chdir(self.working_dir)\n\n            if self.console_encoding:\n                self.command = [s.encode(self.console_encoding) for s in self.command]\n\n            proc = subprocess.Popen(self.command,\n                                    stdout=self.stdout, stderr=subprocess.STDOUT,\n                                    stdin=subprocess.PIPE,\n                                    shell=shell, universal_newlines=False)\n            output = proc.communicate(self.stdin)[0]\n            if not output:\n                output = \'\'\n            # if sublime\'s python gets bumped to 2.7 we can just do:\n            # output = subprocess.check_output(self.command)\n            main_thread(self.on_done,\n                        _make_text_safeish(output, self.fallback_encoding), **self.kwargs)\n        except subprocess.CalledProcessError as e:\n            main_thread(self.on_done, e.returncode)\n        except OSError as e:\n            if e.errno == 2:\n                main_thread(sublime.error_message,\n                            "\'%s\' binary could not be found in PATH\\n\\nConsider using `vcs` property to specify PATH\\n\\nPATH is: %s" % (self.command[0], os.environ[\'PATH\']))\n            else:\n                raise e\n\n\nclass EditViewCommand(sublime_plugin.TextCommand):\n\n    def run(self, edit, command=None, output=\'\', begin=0, region=None):\n        """\n        For some reason Sublime\'s view.run_command() doesn\'t allow to pass tuples,\n        therefore region must be a list\n        """\n        region = sublime.Region(int(region[0]), int(region[1])) if region else None\n        if command == \'insert\':\n            self.view.insert(edit, int(begin), output)\n        elif command == \'replace\':\n            self.view.replace(edit, region, output)\n        elif command == \'erase\':\n            self.view.erase(edit, region)\n        else:\n            print(\'Invalid command: \', command)\n            raise\n\n\nclass VcsCommand(object):\n    may_change_files = False\n\n    def __init__(self, *args, **kwargs):\n        self.settings = get_settings()\n        super(VcsCommand, self).__init__(*args, **kwargs)\n\n    def log(self, *args, **kwargs):\n        return log(settings=self.settings, *args, **kwargs)\n\n    def run_command(self, command, callback=None, show_status=False,\n                    filter_empty_args=True, **kwargs):\n        if filter_empty_args:\n            command = [arg for arg in command if arg]\n        if \'working_dir\' not in kwargs:\n            kwargs[\'working_dir\'] = self.get_working_dir()\n        if \'fallback_encoding\' not in kwargs and self.active_view() and self.active_view().settings().get(\'fallback_encoding\'):\n            kwargs[\'fallback_encoding\'] = self.active_view().settings().get(\'fallback_encoding\').rpartition(\'(\')[2].rpartition(\')\')[0]\n        kwargs[\'console_encoding\'] = self.settings.get(\'console_encoding\')\n\n        autosave = self.settings.get(\'autosave\', True)\n        if self.active_view() and self.active_view().is_dirty() and autosave:\n            self.active_view().run_command(\'save\')\n        if not callback:\n            callback = self.generic_done\n\n        log(\'run command:\', \' \'.join(command))\n        thread = CommandThread(command, callback, **kwargs)\n        thread.start()\n\n        if show_status:\n            message = kwargs.get(\'status_message\', False) or \' \'.join(command)\n            sublime.status_message(message + \'wef\')\n\n    def generic_done(self, result):\n        self.log(\'generic_done\', result)\n        if self.may_change_files and self.active_view() and self.active_view().file_name():\n            if self.active_view().is_dirty():\n                result = "WARNING: Current view is dirty.\\n\\n"\n            else:\n                # just asking the current file to be re-opened doesn\'t do anything\n                print("reverting")\n                position = self.active_view().viewport_position()\n                self.active_view().run_command(\'revert\')\n                do_when(lambda: not self.active_view().is_loading(),\n                        lambda: self.active_view().set_viewport_position(position, False))\n\n        if not result.strip():\n            return\n        self.panel(result)\n\n    def _output_to_view(self, output_file, output, clear=False,\n                        syntax="Packages/Diff/Diff.tmLanguage"):\n        output_file.set_syntax_file(syntax)\n        if clear:\n            output_file.run_command(\'edit_view\', dict(command=\'replace\', region=[0, self.output_view.size()], output=output))\n        else:\n            output_file.run_command(\'edit_view\', dict(command=\'insert\', output=output))\n\n    def scratch(self, output, title=False, position=None, **kwargs):\n        scratch_file = self.get_window().new_file()\n        if title:\n            scratch_file.set_name(title)\n        scratch_file.set_scratch(True)\n        self._output_to_view(scratch_file, output, **kwargs)\n        scratch_file.set_read_only(True)\n        if position:\n            sublime.set_timeout(lambda: scratch_file.set_viewport_position(position), 0)\n        return scratch_file\n\n    def panel(self, output, **kwargs):\n        if not hasattr(self, \'output_view\'):\n            self.output_view = self.get_window().get_output_panel("vcs")\n        self.output_view.set_read_only(False)\n        self._output_to_view(self.output_view, output, clear=True, **kwargs)\n        self.output_view.set_read_only(True)\n        self.get_window().run_command("show_panel", {"panel": "output.vcs"})\n\n    def _active_file_name(self):\n        view = self.active_view()\n        if view and view.file_name() and len(view.file_name()) > 0:\n            return view.file_name()\n\n    def active_view(self):\n        return self.view\n\n    def get_window(self):\n        if (hasattr(self, \'view\') and hasattr(self.view, \'window\')):\n            return self.view.window()\n        else:\n            return sublime.active_window()\n\n    def get_working_dir(self):\n        return os.path.dirname(self._active_file_name())\n\n    def is_enabled(self):\n        file_name = self._active_file_name()\n        if file_name and os.path.exists(file_name):\n            return bool(get_vcs(self.get_working_dir()))\n        return False\n\n\nclass DiffCommand(VcsCommand):\n    """ Here you can define diff commands for your VCS\n        method name pattern: %(vcs_name)s_diff_command\n    """\n\n    def run(self, edit):\n        vcs = get_vcs(self.get_working_dir())\n        filepath = self.view.file_name()\n        filename = os.path.basename(filepath)\n        max_file_size = self.settings.get(\'max_file_size\', 1024) * 1024\n        if not os.path.exists(filepath) or os.path.getsize(filepath) > max_file_size:\n            # skip large files\n            return\n        get_command = getattr(self, \'{0}_diff_command\'.format(vcs[\'name\']), None)\n        if get_command:\n            self.run_command(get_command(filename), self.diff_done)\n\n    def diff_done(self, result):\n        self.log(\'diff_done\', result)\n\n    def git_diff_command(self, file_name):\n        vcs_options = self.settings.get(\'vcs_options\', {}).get(\'git\') or [\'--no-color\', \'--no-ext-diff\']\n        return [get_user_command(\'git\') or \'git\', \'diff\'] + vcs_options + [\'--\', file_name]\n\n    def svn_diff_command(self, file_name):\n        params = [get_user_command(\'svn\') or \'svn\', \'diff\']\n        params.extend(self.settings.get(\'vcs_options\', {}).get(\'svn\', []))\n\n        if \'--internal-diff\' not in params and self.settings.get(\'svn_use_internal_diff\', True):\n            params.append(\'--internal-diff\')\n\n        # if file starts with @, use `--revision HEAD` option\n        # https://github.com/gornostal/Modific/issues/17\n        if file_name.find(\'@\') != -1:\n            file_name += \'@\'\n            params.extend([\'--revision\', \'HEAD\'])\n\n        params.append(file_name)\n        return params\n\n    def bzr_diff_command(self, file_name):\n        vcs_options = self.settings.get(\'vcs_options\', {}).get(\'bzr\', [])\n        return [get_user_command(\'bzr\') or \'bzr\', \'diff\'] + vcs_options + [file_name]\n\n    def hg_diff_command(self, file_name):\n        vcs_options = self.settings.get(\'vcs_options\', {}).get(\'hg\', [])\n        return [get_user_command(\'hg\') or \'hg\', \'diff\'] + vcs_options + [file_name]\n\n    def tf_diff_command(self, file_name):\n        vcs_options = self.settings.get(\'vcs_options\', {}).get(\'tf\') or [\'-format:unified\']\n        return [get_user_command(\'tf\') or \'tf\', \'diff\'] + vcs_options + [file_name]\n\n    def get_line_ending(self):\n        return \'\\n\'\n\n    def join_lines(self, lines):\n        """\n        Join lines using os.linesep.join(), unless another method is specified in ST settings\n        """\n        return self.get_line_ending().join(lines)\n\n\nclass ShowDiffCommand(DiffCommand, sublime_plugin.TextCommand):\n    def diff_done(self, result):\n        self.log(\'on show_diff\', result)\n\n        if not result.strip():\n            return\n\n        result = result.replace(\'\\r\\n\', \'\\n\')\n        file_name = re.findall(r\'([^\\\\\\/]+)$\', self.view.file_name())\n        self.scratch(result, title="Diff - " + file_name[0])\n\n\nclass DiffParser(object):\n    instance = None\n\n    def __init__(self, diff):\n        self.diff = diff\n        self.chunks = None\n        self.__class__.instance = self\n\n    def _append_to_chunks(self, start, lines):\n        self.chunks.append({\n            "start": start,\n            "end": start + len(lines),\n            "lines": lines\n        })\n\n    def get_chunks(self):\n        if self.chunks is None:\n            self.chunks = []\n            diff = self.diff.strip()\n            if diff:\n                re_header = re.compile(r\'^@@[0-9\\-, ]+\\+(\\d+)\', re.S)\n                current = None\n                lines = []\n                for line in diff.splitlines():\n                    # ignore lines with \'\\\' at the beginning\n                    if line.startswith(\'\\\\\'):\n                        continue\n\n                    matches = re.findall(re_header, line)\n                    if matches:\n                        if current is not None:\n                            self._append_to_chunks(current, lines)\n                        current = int(matches[0])\n                        lines = []\n                    elif current:\n                        lines.append(line)\n                if current is not None and lines:\n                    self._append_to_chunks(current, lines)\n\n        return self.chunks\n\n    def get_lines_to_hl(self):\n        inserted = []\n        changed = []\n        deleted = []\n\n        for chunk in self.get_chunks():\n            current = chunk[\'start\']\n            deleted_line = None\n            for line in chunk[\'lines\']:\n                if line.startswith(\'-\'):\n                    if (not deleted_line or deleted_line not in deleted):\n                        deleted.append(current)\n                    deleted_line = current\n                elif line.startswith(\'+\'):\n                    if deleted_line:\n                        deleted.pop()\n                        deleted_line = None\n                        changed.append(current)\n                    elif current - 1 in changed:\n                        changed.append(current)\n                    else:\n                        inserted.append(current)\n                    current += 1\n                else:\n                    deleted_line = None\n                    current += 1\n\n        return inserted, changed, deleted\n\n    def get_original_part(self, line_num):\n        """ returns a chunk of code that relates to the given line\n            and was there before modifications\n\n            return (lines list, start_line int, replace_lines int)\n        """\n\n        # for each chunk from diff:\n        for chunk in self.get_chunks():\n            # if line_num is within that chunk\n            if chunk[\'start\'] <= line_num <= chunk[\'end\']:\n                ret_lines = []\n                current = chunk[\'start\']  # line number that corresponds to current version of file\n                first = None  # number of the first line to change\n                replace_lines = 0  # number of lines to change\n                return_this_lines = False  # flag shows whether we can return accumulated lines\n                for line in chunk[\'lines\']:\n                    if line.startswith(\'-\') or line.startswith(\'+\'):\n                        first = first or current\n                        if current == line_num:\n                            return_this_lines = True\n                        if line.startswith(\'-\'):\n                            # if line starts with \'-\' we have previous version\n                            ret_lines.append(line[1:])\n                        else:\n                            # if line starts with \'+\' we only increment numbers\n                            replace_lines += 1\n                            current += 1\n                    elif return_this_lines:\n                        break\n                    else:\n                        # gap between modifications\n                        # reset our variables\n                        current += 1\n                        first = current\n                        replace_lines = 0\n                        ret_lines = []\n                if return_this_lines:\n                    return ret_lines, first, replace_lines\n\n        return None, None, None\n\n\nclass HlChangesCommand(DiffCommand, sublime_plugin.TextCommand):\n    def hl_lines(self, lines, hl_key):\n        if (not len(lines) or not self.settings.get(\'highlight_changes\')):\n            self.view.erase_regions(hl_key)\n            return\n\n        icon = self.settings.get(\'region_icon\') or \'modific\'\n        if icon == \'modific\':\n            if IS_ST3:\n                icon = \'Packages/Modific/icons/\' + hl_key + \'.png\'\n            else:\n                icon = \'../Modific/icons/\' + hl_key\n        points = [self.view.text_point(l - 1, 0) for l in lines]\n        regions = [sublime.Region(p, p) for p in points]\n        self.view.add_regions(hl_key, regions, "markup.%s.diff" % hl_key, icon, sublime.HIDDEN | sublime.DRAW_EMPTY)\n\n    def diff_done(self, diff):\n        self.log(\'on hl_changes:\', diff)\n\n        if diff and \'@@\' not in diff:\n            # probably this is an error message\n            # if print raise UnicodeEncodeError, try to encode string to utf-8 (issue #35)\n            try:\n                print(diff)\n            except UnicodeEncodeError:\n                print(diff.encode(\'utf-8\'))\n\n        diff_parser = DiffParser(diff)\n        (inserted, changed, deleted) = diff_parser.get_lines_to_hl()\n\n        self.log(\'new lines:\', inserted)\n        self.log(\'modified lines:\', changed)\n        self.log(\'deleted lines:\', deleted)\n\n        self.hl_lines(inserted, \'inserted\')\n        self.hl_lines(deleted, \'deleted\')\n        self.hl_lines(changed, \'changed\')\n\n\nclass ShowOriginalPartCommand(DiffCommand, sublime_plugin.TextCommand):\n    def run(self, edit):\n        diff_parser = DiffParser.instance\n        if not diff_parser:\n            return\n\n        (row, col) = self.view.rowcol(self.view.sel()[0].begin())\n        (lines, start, replace_lines) = diff_parser.get_original_part(row + 1)\n        if lines is not None:\n            self.panel(self.join_lines(lines))\n\n\nclass ReplaceModifiedPartCommand(DiffCommand, sublime_plugin.TextCommand):\n    def run(self, edit):\n        self.view.run_command(\'save\')\n\n        diff_parser = DiffParser.instance\n        if not diff_parser:\n            return\n\n        (row, col) = self.view.rowcol(self.view.sel()[0].begin())\n        (lines, current, replace_lines) = diff_parser.get_original_part(row + 1)\n        if self.settings.get(\'debug\'):\n            print(\'replace\', (lines, current, replace_lines))\n        if lines is not None:\n            begin = self.view.text_point(current - 1, 0)\n            content = self.join_lines(lines)\n            if replace_lines:\n                end = self.view.line(self.view.text_point(replace_lines + current - 2, 0)).end()\n                region = sublime.Region(begin, end)\n                if lines:\n                    self.view.run_command(\'edit_view\', dict(command=\'replace\', region=[region.begin(), region.end()], output=content))\n                else:\n                    region = self.view.full_line(region)\n                    self.view.run_command(\'edit_view\', dict(command=\'erase\', region=[region.begin(), region.end()]))\n            else:\n                self.view.run_command(\'edit_view\', dict(command=\'insert\', begin=begin,\n                                                        output=content + self.get_line_ending()))\n            self.view.run_command(\'save\')\n\n\nclass HlChangesBackground(sublime_plugin.EventListener):\n    def on_load(self, view):\n        if not IS_ST3:\n            view.run_command(\'hl_changes\')\n\n    def on_load_async(self, view):\n        view.run_command(\'hl_changes\')\n\n    def on_activated(self, view):\n        if not IS_ST3:\n            view.run_command(\'hl_changes\')\n\n    def on_activated_async(self, view):\n        view.run_command(\'hl_changes\')\n\n    def on_post_save(self, view):\n        if not IS_ST3:\n            view.run_command(\'hl_changes\')\n\n    def on_post_save_async(self, view):\n        view.run_command(\'hl_changes\')\n\n\nclass JumpBetweenChangesCommand(DiffCommand, sublime_plugin.TextCommand):\n    def run(self, edit, direction=\'next\'):\n        lines = self._get_lines()\n        if not lines:\n            return\n\n        if direction == \'prev\':\n            lines.reverse()\n\n        (current_line, col) = self.view.rowcol(self.view.sel()[0].begin())\n        current_line += 1\n        jump_to = None\n        for line in lines:\n            if direction == \'next\' and current_line < line:\n                jump_to = line\n                break\n            if direction == \'prev\' and current_line > line:\n                jump_to = line\n                break\n\n        if not jump_to:\n            jump_to = lines[0]\n\n        self.goto_line(edit, jump_to)\n\n    def goto_line(self, edit, line):\n        # Convert from 1 based to a 0 based line number\n        line = int(line) - 1\n\n        # Negative line numbers count from the end of the buffer\n        if line < 0:\n            lines, _ = self.view.rowcol(self.view.size())\n            line = lines + line + 1\n\n        pt = self.view.text_point(line, 0)\n\n        self.view.sel().clear()\n        self.view.sel().add(sublime.Region(pt))\n\n        self.view.show(pt)\n\n    def _get_lines(self):\n        diff_parser = DiffParser.instance\n        if not diff_parser:\n            return\n\n        (inserted, changed, deleted) = diff_parser.get_lines_to_hl()\n        lines = list(set(inserted + changed + deleted))\n        lines.sort()\n\n        prev = None\n        ret_lines = []\n        for line in lines:\n            if prev != line - 1:\n                ret_lines.append(line)\n            prev = line\n\n        return ret_lines\n\n\nclass UncommittedFilesCommand(VcsCommand, sublime_plugin.WindowCommand):\n    def active_view(self):\n        return self.window.active_view()\n\n    def is_enabled(self):\n        return bool(self.get_working_dir())\n\n    def get_working_dir(self):\n        if self._active_file_name():\n            working_dir = super(UncommittedFilesCommand, self).get_working_dir()\n            if working_dir and get_vcs(working_dir):\n                return working_dir\n\n        # If the user has opened a vcs folder, use it.\n        folders = self.window.folders()\n        for folder in folders:\n            if folder and os.path.exists(folder) and get_vcs(folder):\n                return folder\n\n    def run(self):\n        self.vcs = get_vcs(self.get_working_dir())\n        status_command = getattr(self, \'{0}_status_command\'.format(self.vcs[\'name\']), None)\n        if status_command:\n            self.run_command(status_command(), self.status_done, working_dir=self.vcs[\'root\'])\n\n    def git_status_command(self):\n        return [get_user_command(\'git\') or \'git\', \'status\', \'--porcelain\']\n\n    def svn_status_command(self):\n        return [get_user_command(\'svn\') or \'svn\', \'status\', \'--quiet\']\n\n    def bzr_status_command(self):\n        return [get_user_command(\'bzr\') or \'bzr\', \'status\', \'-S\', \'--no-pending\', \'-V\']\n\n    def hg_status_command(self):\n        return [get_user_command(\'hg\') or \'hg\', \'status\']\n\n    def tf_status_command(self):\n        return [get_user_command(\'tf\') or \'tf\', \'status\']\n\n    def filter_unified_status(self, result):\n        return list(filter(lambda x: len(x) > 0 and not x.lstrip().startswith(\'>\'),\n                    result.rstrip().split(\'\\n\')))\n\n    def git_filter_status(self, result):\n        return self.filter_unified_status(result)\n\n    def svn_filter_status(self, result):\n        return self.filter_unified_status(result)\n\n    def bzr_filter_status(self, result):\n        return self.filter_unified_status(result)\n\n    def hg_filter_status(self, result):\n        return self.filter_unified_status(result)\n\n    def tf_filter_status(self, result):\n        filtered = []\n        can_add = False\n        for line in result.split(\'\\n\'):\n            if line.startswith(\'$\'):\n                can_add = True\n                continue\n            if line == \'\':\n                can_add = False\n                continue\n            if can_add:\n                filtered.append(line)\n\n        return filtered\n\n    def git_status_file(self, file_name):\n        # first 2 characters are status codes, the third is a space\n        return file_name[3:]\n\n    def svn_status_file(self, file_name):\n        return file_name[8:]\n\n    def bzr_status_file(self, file_name):\n        return file_name[4:]\n\n    def hg_status_file(self, file_name):\n        return file_name[2:]\n\n    def tf_status_file(self, file_name):\n        try:\n            # assume that file name should always contain colon\n            return re.findall(r\'\\s+(\\S+:.+)$\', file_name)[0]\n        except:\n            return None\n\n    def status_done(self, result):\n        filter_status = getattr(self, \'{0}_filter_status\'.format(self.vcs[\'name\']), None)\n\n        self.results = [item.replace(\'\\r\', \'\') for item in filter_status(result)]\n\n        if self.results:\n            self.show_status_list()\n        else:\n            sublime.status_message("Nothing to show")\n\n    def show_status_list(self):\n        options = copy(self.results)\n        options.insert(0, " - Open All")\n        self.get_window().show_quick_panel(options, self.panel_done, sublime.MONOSPACE_FONT)\n\n    def panel_done(self, picked):\n        if picked == 0:\n            self.open_files(*self.results)\n            return\n        elif 0 > picked < len(self.results):\n            return\n        picked_file = self.results[picked - 1]\n        self.open_files(picked_file)\n\n    def open_files(self, *files):\n        for f in files:\n            get_file = getattr(self, \'{0}_status_file\'.format(self.vcs[\'name\']), None)\n            if get_file:\n                fname = get_file(f)\n                if os.path.isfile(os.path.join(self.vcs[\'root\'], fname)):\n                    self.window.open_file(os.path.join(self.vcs[\'root\'], fname))\n                else:\n                    sublime.status_message("File \'{0}\' doesn\'t exist".format(fname))\n\n\nclass ToggleHighlightChangesCommand(sublime_plugin.TextCommand):\n    def run(self, edit):\n        setting_name = "highlight_changes"\n        settings = get_settings()\n        is_on = settings.get(setting_name)\n\n        if is_on:\n            # remove highlighting\n            [self.view.erase_regions(k) for k in (\'inserted\', \'changed\', \'deleted\')]\n        else:\n            self.view.run_command(\'hl_changes\')\n\n        settings.set(setting_name, not is_on)\n        sublime.save_settings("Modific.sublime-settings")\n'program output:b'# -*- coding: utf-8 -*-\n\nfrom __future__ import print_function\n\nimport sublime\nimport sublime_plugin\nimport os\nimport threading\nimport subprocess\nimport functools\nimport re\nfrom copy import copy\n\nIS_ST3 = sublime.version().startswith(\'3\')\n\n\ndef get_settings():\n    return sublime.load_settings("Modific.sublime-settings")\n\n\ndef get_vcs_settings():\n    """\n    Returns list of dictionaries\n    each dict. represents settings for VCS\n    """\n\n    default = [\n        {"name": "git", "dir": ".git", "cmd": "git"},\n        {"name": "svn", "dir": ".svn", "cmd": "svn"},\n        {"name": "bzr", "dir": ".bzr", "cmd": "bzr"},\n        {"name": "hg",  "dir": ".hg",  "cmd": "hg"},\n        {"name": "tf",  "dir": "$tf",  "cmd": "C:/Program Files (x86)/Microsoft Visual Studio 11.0/Common7/IDE/TF.exe"}\n    ]\n    settings = get_settings().get(\'vcs\', default)\n\n    # re-format settings array if user has old format of settings\n    if type(settings[0]) == list:\n        settings = [dict(name=name, cmd=cmd, dir=\'.\'+name) for name, cmd in settings]\n\n    return settings\n\n\ndef get_user_command(vcs_name):\n    """\n    Returns command that user specified for vcs_name\n    """\n\n    try:\n        return [vcs[\'cmd\'] for vcs in get_vcs_settings() if vcs.get(\'name\') == vcs_name][0]\n    except IndexError:\n        return None\n\n\ndef tfs_root(directory):\n    try:\n        tf_cmd = get_user_command(\'tf\') or \'tf\'\n        command = [tf_cmd, \'workfold\', directory]\n        p = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE,\n                             shell=True, universal_newlines=False)\n        out, err = p.communicate()\n        m = re.search(r"^ \\$\\S+: (\\S+)$", out, re.MULTILINE)\n        if m:\n            return {\'root\': m.group(1), \'name\': \'tf\', \'cmd\': tf_cmd}\n    except:\n        return None\n\n\ndef get_vcs(directory):\n    """\n    Determines root directory for VCS and which of VCS systems should be used for a given directory\n\n    Returns dictionary {name: .., root: .., cmd: .., dir: ..}\n    """\n\n    vcs_check = [(lambda vcs: lambda dir: os.path.exists(os.path.join(dir, vcs.get(\'dir\', False)))\n                 and vcs)(vcs) for vcs in get_vcs_settings()]\n\n    start_directory = directory\n    while directory:\n        available = list(filter(bool, [check(directory) for check in vcs_check]))\n        if available:\n            available[0][\'root\'] = directory\n            return available[0]\n\n        parent = os.path.realpath(os.path.join(directory, os.path.pardir))\n        if parent == directory:  # /.. == /\n            # try TFS as a last resort\n            # I\'m not sure why we need to do this. Seems like it should find root for TFS in the main loop\n            return tfs_root(start_directory)\n        directory = parent\n\n    return None\n\n\ndef main_thread(callback, *args, **kwargs):\n    # sublime.set_timeout gets used to send things onto the main thread\n    # most sublime.[something] calls need to be on the main thread\n    sublime.set_timeout(functools.partial(callback, *args, **kwargs), 0)\n\n\ndef _make_text_safeish(text, fallback_encoding, method=\'decode\'):\n    # The unicode decode here is because sublime converts to unicode inside\n    # insert in such a way that unknown characters will cause errors, which is\n    # distinctly non-ideal... and there\'s no way to tell what\'s coming out of\n    # git in output. So...\n    try:\n        unitext = getattr(text, method)(\'utf-8\')\n    except (UnicodeEncodeError, UnicodeDecodeError):\n        unitext = getattr(text, method)(fallback_encoding)\n    except AttributeError:\n        # strongly implies we\'re already unicode, but just in case let\'s cast\n        # to string\n        unitext = str(text)\n    return unitext\n\n\ndef do_when(conditional, callback, *args, **kwargs):\n    if conditional():\n        return callback(*args, **kwargs)\n    sublime.set_timeout(functools.partial(do_when, conditional, callback, *args, **kwargs), 50)\n\n\ndef log(*args, **kwargs):\n    """\n    @param *args: string arguments that should be logged to console\n    @param debug=True: debug log mode\n    @param settings=None: instance of sublime.Settings\n    """\n    debug = kwargs.get(\'debug\', True)\n    settings = kwargs.get(\'settings\', None)\n\n    if not settings:\n        settings = get_settings()\n\n    if debug and not settings.get(\'debug\', False):\n        return\n\n    print(\'Modific:\', *args)\n\n\nclass CommandThread(threading.Thread):\n\n    def __init__(self, command, on_done, working_dir="", fallback_encoding="", console_encoding="", **kwargs):\n        threading.Thread.__init__(self)\n        self.command = command\n        self.on_done = on_done\n        self.working_dir = working_dir\n        if \'stdin\' in kwargs:\n            self.stdin = kwargs[\'stdin\'].encode()\n        else:\n            self.stdin = None\n        self.stdout = kwargs.get(\'stdout\', subprocess.PIPE)\n        self.console_encoding = console_encoding\n        self.fallback_encoding = fallback_encoding\n        self.kwargs = kwargs\n\n    def run(self):\n        try:\n            # Per http://bugs.python.org/issue8557 shell=True is required to\n            # get $PATH on Windows. Yay portable code.\n            shell = os.name == \'nt\'\n\n            if self.working_dir != "":\n                os.chdir(self.working_dir)\n\n            if self.console_encoding:\n                self.command = [s.encode(self.console_encoding) for s in self.command]\n\n            proc = subprocess.Popen(self.command,\n                                    stdout=self.stdout, stderr=subprocess.STDOUT,\n                                    stdin=subprocess.PIPE,\n                                    shell=shell, universal_newlines=False)\n            output = proc.communicate(self.stdin)[0]\n            if not output:\n                output = \'\'\n            # if sublime\'s python gets bumped to 2.7 we can just do:\n            # output = subprocess.check_output(self.command)\n            main_thread(self.on_done,\n                        _make_text_safeish(output, self.fallback_encoding), **self.kwargs)\n        except subprocess.CalledProcessError as e:\n            main_thread(self.on_done, e.returncode)\n        except OSError as e:\n            if e.errno == 2:\n                main_thread(sublime.error_message,\n                            "\'%s\' binary could not be found in PATH\\n\\nConsider using `vcs` property to specify PATH\\n\\nPATH is: %s" % (self.command[0], os.environ[\'PATH\']))\n            else:\n                raise e\n\n\nclass EditViewCommand(sublime_plugin.TextCommand):\n\n    def run(self, edit, command=None, output=\'\', begin=0, region=None):\n        """\n        For some reason Sublime\'s view.run_command() doesn\'t allow to pass tuples,\n        therefore region must be a list\n        """\n        region = sublime.Region(int(region[0]), int(region[1])) if region else None\n        if command == \'insert\':\n            self.view.insert(edit, int(begin), output)\n        elif command == \'replace\':\n            self.view.replace(edit, region, output)\n        elif command == \'erase\':\n            self.view.erase(edit, region)\n        else:\n            print(\'Invalid command: \', command)\n            raise\n\n\nclass VcsCommand(object):\n    may_change_files = False\n\n    def __init__(self, *args, **kwargs):\n        self.settings = get_settings()\n        super(VcsCommand, self).__init__(*args, **kwargs)\n\n    def log(self, *args, **kwargs):\n        return log(settings=self.settings, *args, **kwargs)\n\n    def run_command(self, command, callback=None, show_status=False,\n                    filter_empty_args=True, **kwargs):\n        if filter_empty_args:\n            command = [arg for arg in command if arg]\n        if \'working_dir\' not in kwargs:\n            kwargs[\'working_dir\'] = self.get_working_dir()\n        if \'fallback_encoding\' not in kwargs and self.active_view() and self.active_view().settings().get(\'fallback_encoding\'):\n            kwargs[\'fallback_encoding\'] = self.active_view().settings().get(\'fallback_encoding\').rpartition(\'(\')[2].rpartition(\')\')[0]\n        kwargs[\'console_encoding\'] = self.settings.get(\'console_encoding\')\n\n        autosave = self.settings.get(\'autosave\', True)\n        if self.active_view() and self.active_view().is_dirty() and autosave:\n            self.active_view().run_command(\'save\')\n        if not callback:\n            callback = self.generic_done\n\n        log(\'run command:\', \' \'.join(command))\n        thread = CommandThread(command, callback, **kwargs)\n        thread.start()\n\n        if show_status:\n            message = kwargs.get(\'status_message\', False) or \' \'.join(command)\n            sublime.status_message(message + \'wef\')\n\n    def generic_done(self, result):\n        self.log(\'generic_done\', result)\n        if self.may_change_files and self.active_view() and self.active_view().file_name():\n            if self.active_view().is_dirty():\n                result = "WARNING: Current view is dirty.\\n\\n"\n            else:\n                # just asking the current file to be re-opened doesn\'t do anything\n                print("reverting")\n                position = self.active_view().viewport_position()\n                self.active_view().run_command(\'revert\')\n                do_when(lambda: not self.active_view().is_loading(),\n                        lambda: self.active_view().set_viewport_position(position, False))\n\n        if not result.strip():\n            return\n        self.panel(result)\n\n    def _output_to_view(self, output_file, output, clear=False,\n                        syntax="Packages/Diff/Diff.tmLanguage"):\n        output_file.set_syntax_file(syntax)\n        if clear:\n            output_file.run_command(\'edit_view\', dict(command=\'replace\', region=[0, self.output_view.size()], output=output))\n        else:\n            output_file.run_command(\'edit_view\', dict(command=\'insert\', output=output))\n\n    def scratch(self, output, title=False, position=None, **kwargs):\n        scratch_file = self.get_window().new_file()\n        if title:\n            scratch_file.set_name(title)\n        scratch_file.set_scratch(True)\n        self._output_to_view(scratch_file, output, **kwargs)\n        scratch_file.set_read_only(True)\n        if position:\n            sublime.set_timeout(lambda: scratch_file.set_viewport_position(position), 0)\n        return scratch_file\n\n    def panel(self, output, **kwargs):\n        if not hasattr(self, \'output_view\'):\n            self.output_view = self.get_window().get_output_panel("vcs")\n        self.output_view.set_read_only(False)\n        self._output_to_view(self.output_view, output, clear=True, **kwargs)\n        self.output_view.set_read_only(True)\n        self.get_window().run_command("show_panel", {"panel": "output.vcs"})\n\n    def _active_file_name(self):\n        view = self.active_view()\n        if view and view.file_name() and len(view.file_name()) > 0:\n            return view.file_name()\n\n    def active_view(self):\n        return self.view\n\n    def get_window(self):\n        if (hasattr(self, \'view\') and hasattr(self.view, \'window\')):\n            return self.view.window()\n        else:\n            return sublime.active_window()\n\n    def get_working_dir(self):\n        return os.path.dirname(self._active_file_name())\n\n    def is_enabled(self):\n        file_name = self._active_file_name()\n        if file_name and os.path.exists(file_name):\n            return bool(get_vcs(self.get_working_dir()))\n        return False\n\n\nclass DiffCommand(VcsCommand):\n    """ Here you can define diff commands for your VCS\n        method name pattern: %(vcs_name)s_diff_command\n    """\n\n    def run(self, edit):\n        vcs = get_vcs(self.get_working_dir())\n        filepath = self.view.file_name()\n        filename = os.path.basename(filepath)\n        max_file_size = self.settings.get(\'max_file_size\', 1024) * 1024\n        if not os.path.exists(filepath) or os.path.getsize(filepath) > max_file_size:\n            # skip large files\n            return\n        get_command = getattr(self, \'{0}_diff_command\'.format(vcs[\'name\']), None)\n        if get_command:\n            self.run_command(get_command(filename), self.diff_done)\n\n    def diff_done(self, result):\n        self.log(\'diff_done\', result)\n\n    def git_diff_command(self, file_name):\n        vcs_options = self.settings.get(\'vcs_options\', {}).get(\'git\') or [\'--no-color\', \'--no-ext-diff\']\n        return [get_user_command(\'git\') or \'git\', \'diff\'] + vcs_options + [\'--\', file_name]\n\n    def svn_diff_command(self, file_name):\n        params = [get_user_command(\'svn\') or \'svn\', \'diff\']\n        params.extend(self.settings.get(\'vcs_options\', {}).get(\'svn\', []))\n\n        if \'--internal-diff\' not in params and self.settings.get(\'svn_use_internal_diff\', True):\n            params.append(\'--internal-diff\')\n\n        # if file starts with @, use `--revision HEAD` option\n        # https://github.com/gornostal/Modific/issues/17\n        if file_name.find(\'@\') != -1:\n            file_name += \'@\'\n            params.extend([\'--revision\', \'HEAD\'])\n\n        params.append(file_name)\n        return params\n\n    def bzr_diff_command(self, file_name):\n        vcs_options = self.settings.get(\'vcs_options\', {}).get(\'bzr\', [])\n        return [get_user_command(\'bzr\') or \'bzr\', \'diff\'] + vcs_options + [file_name]\n\n    def hg_diff_command(self, file_name):\n        vcs_options = self.settings.get(\'vcs_options\', {}).get(\'hg\', [])\n        return [get_user_command(\'hg\') or \'hg\', \'diff\'] + vcs_options + [file_name]\n\n    def tf_diff_command(self, file_name):\n        vcs_options = self.settings.get(\'vcs_options\', {}).get(\'tf\') or [\'-format:unified\']\n        return [get_user_command(\'tf\') or \'tf\', \'diff\'] + vcs_options + [file_name]\n\n    def get_line_ending(self):\n        return \'\\n\'\n\n    def join_lines(self, lines):\n        """\n        Join lines using os.linesep.join(), unless another method is specified in ST settings\n        """\n        return self.get_line_ending().join(lines)\n\n\nclass ShowDiffCommand(DiffCommand, sublime_plugin.TextCommand):\n    def diff_done(self, result):\n        self.log(\'on show_diff\', result)\n\n        if not result.strip():\n            return\n\n        result = result.replace(\'\\r\\n\', \'\\n\')\n        file_name = re.findall(r\'([^\\\\\\/]+)$\', self.view.file_name())\n        self.scratch(result, title="Diff - " + file_name[0])\n\n\nclass DiffParser(object):\n    instance = None\n\n    def __init__(self, diff):\n        self.diff = diff\n        self.chunks = None\n        self.__class__.instance = self\n\n    def _append_to_chunks(self, start, lines):\n        self.chunks.append({\n            "start": start,\n            "end": start + len(lines),\n            "lines": lines\n        })\n\n    def get_chunks(self):\n        if self.chunks is None:\n            self.chunks = []\n            diff = self.diff.strip()\n            if diff:\n                re_header = re.compile(r\'^@@[0-9\\-, ]+\\+(\\d+)\', re.S)\n                current = None\n                lines = []\n                for line in diff.splitlines():\n                    # ignore lines with \'\\\' at the beginning\n                    if line.startswith(\'\\\\\'):\n                        continue\n\n                    matches = re.findall(re_header, line)\n                    if matches:\n                        if current is not None:\n                            self._append_to_chunks(current, lines)\n                        current = int(matches[0])\n                        lines = []\n                    elif current:\n                        lines.append(line)\n                if current is not None and lines:\n                    self._append_to_chunks(current, lines)\n\n        return self.chunks\n\n    def get_lines_to_hl(self):\n        inserted = []\n        changed = []\n        deleted = []\n\n        for chunk in self.get_chunks():\n            current = chunk[\'start\']\n            deleted_line = None\n            for line in chunk[\'lines\']:\n                if line.startswith(\'-\'):\n                    if (not deleted_line or deleted_line not in deleted):\n                        deleted.append(current)\n                    deleted_line = current\n                elif line.startswith(\'+\'):\n                    if deleted_line:\n                        deleted.pop()\n                        deleted_line = None\n                        changed.append(current)\n                    elif current - 1 in changed:\n                        changed.append(current)\n                    else:\n                        inserted.append(current)\n                    current += 1\n                else:\n                    deleted_line = None\n                    current += 1\n\n        return inserted, changed, deleted\n\n    def get_original_part(self, line_num):\n        """ returns a chunk of code that relates to the given line\n            and was there before modifications\n\n            return (lines list, start_line int, replace_lines int)\n        """\n\n        # for each chunk from diff:\n        for chunk in self.get_chunks():\n            # if line_num is within that chunk\n            if chunk[\'start\'] <= line_num <= chunk[\'end\']:\n                ret_lines = []\n                current = chunk[\'start\']  # line number that corresponds to current version of file\n                first = None  # number of the first line to change\n                replace_lines = 0  # number of lines to change\n                return_this_lines = False  # flag shows whether we can return accumulated lines\n                for line in chunk[\'lines\']:\n                    if line.startswith(\'-\') or line.startswith(\'+\'):\n                        first = first or current\n                        if current == line_num:\n                            return_this_lines = True\n                        if line.startswith(\'-\'):\n                            # if line starts with \'-\' we have previous version\n                            ret_lines.append(line[1:])\n                        else:\n                            # if line starts with \'+\' we only increment numbers\n                            replace_lines += 1\n                            current += 1\n                    elif return_this_lines:\n                        break\n                    else:\n                        # gap between modifications\n                        # reset our variables\n                        current += 1\n                        first = current\n                        replace_lines = 0\n                        ret_lines = []\n                if return_this_lines:\n                    return ret_lines, first, replace_lines\n\n        return None, None, None\n\n\nclass HlChangesCommand(DiffCommand, sublime_plugin.TextCommand):\n    def hl_lines(self, lines, hl_key):\n        if (not len(lines) or not self.settings.get(\'highlight_changes\')):\n            self.view.erase_regions(hl_key)\n            return\n\n        icon = self.settings.get(\'region_icon\') or \'modific\'\n        if icon == \'modific\':\n            if IS_ST3:\n                icon = \'Packages/Modific/icons/\' + hl_key + \'.png\'\n            else:\n                icon = \'../Modific/icons/\' + hl_key\n        points = [self.view.text_point(l - 1, 0) for l in lines]\n        regions = [sublime.Region(p, p) for p in points]\n        self.view.add_regions(hl_key, regions, "markup.%s.diff" % hl_key, icon, sublime.HIDDEN | sublime.DRAW_EMPTY)\n\n    def diff_done(self, diff):\n        self.log(\'on hl_changes:\', diff)\n\n        if diff and \'@@\' not in diff:\n            # probably this is an error message\n            # if print raise UnicodeEncodeError, try to encode string to utf-8 (issue #35)\n            try:\n                print(diff)\n            except UnicodeEncodeError:\n                print(diff.encode(\'utf-8\'))\n\n        diff_parser = DiffParser(diff)\n        (inserted, changed, deleted) = diff_parser.get_lines_to_hl()\n\n        self.log(\'new lines:\', inserted)\n        self.log(\'modified lines:\', changed)\n        self.log(\'deleted lines:\', deleted)\n\n        self.hl_lines(inserted, \'inserted\')\n        self.hl_lines(deleted, \'deleted\')\n        self.hl_lines(changed, \'changed\')\n\n\nclass ShowOriginalPartCommand(DiffCommand, sublime_plugin.TextCommand):\n    def run(self, edit):\n        diff_parser = DiffParser.instance\n        if not diff_parser:\n            return\n\n        (row, col) = self.view.rowcol(self.view.sel()[0].begin())\n        (lines, start, replace_lines) = diff_parser.get_original_part(row + 1)\n        if lines is not None:\n            self.panel(self.join_lines(lines))\n\n\nclass ReplaceModifiedPartCommand(DiffCommand, sublime_plugin.TextCommand):\n    def run(self, edit):\n        self.view.run_command(\'save\')\n\n        diff_parser = DiffParser.instance\n        if not diff_parser:\n            return\n\n        (row, col) = self.view.rowcol(self.view.sel()[0].begin())\n        (lines, current, replace_lines) = diff_parser.get_original_part(row + 1)\n        if self.settings.get(\'debug\'):\n            print(\'replace\', (lines, current, replace_lines))\n        if lines is not None:\n            begin = self.view.text_point(current - 1, 0)\n            content = self.join_lines(lines)\n            if replace_lines:\n                end = self.view.line(self.view.text_point(replace_lines + current - 2, 0)).end()\n                region = sublime.Region(begin, end)\n                if lines:\n                    self.view.run_command(\'edit_view\', dict(command=\'replace\', region=[region.begin(), region.end()], output=content))\n                else:\n                    region = self.view.full_line(region)\n                    self.view.run_command(\'edit_view\', dict(command=\'erase\', region=[region.begin(), region.end()]))\n            else:\n                self.view.run_command(\'edit_view\', dict(command=\'insert\', begin=begin,\n                                                        output=content + self.get_line_ending()))\n            self.view.run_command(\'save\')\n\n\nclass HlChangesBackground(sublime_plugin.EventListener):\n    def on_load(self, view):\n        if not IS_ST3:\n            view.run_command(\'hl_changes\')\n\n    def on_load_async(self, view):\n        view.run_command(\'hl_changes\')\n\n    def on_activated(self, view):\n        if not IS_ST3:\n            view.run_command(\'hl_changes\')\n\n    def on_activated_async(self, view):\n        view.run_command(\'hl_changes\')\n\n    def on_post_save(self, view):\n        if not IS_ST3:\n            view.run_command(\'hl_changes\')\n\n    def on_post_save_async(self, view):\n        view.run_command(\'hl_changes\')\n\n\nclass JumpBetweenChangesCommand(DiffCommand, sublime_plugin.TextCommand):\n    def run(self, edit, direction=\'next\'):\n        lines = self._get_lines()\n        if not lines:\n            return\n\n        if direction == \'prev\':\n            lines.reverse()\n\n        (current_line, col) = self.view.rowcol(self.view.sel()[0].begin())\n        current_line += 1\n        jump_to = None\n        for line in lines:\n            if direction == \'next\' and current_line < line:\n                jump_to = line\n                break\n            if direction == \'prev\' and current_line > line:\n                jump_to = line\n                break\n\n        if not jump_to:\n            jump_to = lines[0]\n\n        self.goto_line(edit, jump_to)\n\n    def goto_line(self, edit, line):\n        # Convert from 1 based to a 0 based line number\n        line = int(line) - 1\n\n        # Negative line numbers count from the end of the buffer\n        if line < 0:\n            lines, _ = self.view.rowcol(self.view.size())\n            line = lines + line + 1\n\n        pt = self.view.text_point(line, 0)\n\n        self.view.sel().clear()\n        self.view.sel().add(sublime.Region(pt))\n\n        self.view.show(pt)\n\n    def _get_lines(self):\n        diff_parser = DiffParser.instance\n        if not diff_parser:\n            return\n\n        (inserted, changed, deleted) = diff_parser.get_lines_to_hl()\n        lines = list(set(inserted + changed + deleted))\n        lines.sort()\n\n        prev = None\n        ret_lines = []\n        for line in lines:\n            if prev != line - 1:\n                ret_lines.append(line)\n            prev = line\n\n        return ret_lines\n\n\nclass UncommittedFilesCommand(VcsCommand, sublime_plugin.WindowCommand):\n    def active_view(self):\n        return self.window.active_view()\n\n    def is_enabled(self):\n        return bool(self.get_working_dir())\n\n    def get_working_dir(self):\n        if self._active_file_name():\n            working_dir = super(UncommittedFilesCommand, self).get_working_dir()\n            if working_dir and get_vcs(working_dir):\n                return working_dir\n\n        # If the user has opened a vcs folder, use it.\n        folders = self.window.folders()\n        for folder in folders:\n            if folder and os.path.exists(folder) and get_vcs(folder):\n                return folder\n\n    def run(self):\n        self.vcs = get_vcs(self.get_working_dir())\n        status_command = getattr(self, \'{0}_status_command\'.format(self.vcs[\'name\']), None)\n        if status_command:\n            self.run_command(status_command(), self.status_done, working_dir=self.vcs[\'root\'])\n\n    def git_status_command(self):\n        return [get_user_command(\'git\') or \'git\', \'status\', \'--porcelain\']\n\n    def svn_status_command(self):\n        return [get_user_command(\'svn\') or \'svn\', \'status\', \'--quiet\']\n\n    def bzr_status_command(self):\n        return [get_user_command(\'bzr\') or \'bzr\', \'status\', \'-S\', \'--no-pending\', \'-V\']\n\n    def hg_status_command(self):\n        return [get_user_command(\'hg\') or \'hg\', \'status\']\n\n    def tf_status_command(self):\n        return [get_user_command(\'tf\') or \'tf\', \'status\']\n\n    def filter_unified_status(self, result):\n        return list(filter(lambda x: len(x) > 0 and not x.lstrip().startswith(\'>\'),\n                    result.rstrip().split(\'\\n\')))\n\n    def git_filter_status(self, result):\n        return self.filter_unified_status(result)\n\n    def svn_filter_status(self, result):\n        return self.filter_unified_status(result)\n\n    def bzr_filter_status(self, result):\n        return self.filter_unified_status(result)\n\n    def hg_filter_status(self, result):\n        return self.filter_unified_status(result)\n\n    def tf_filter_status(self, result):\n        filtered = []\n        can_add = False\n        for line in result.split(\'\\n\'):\n            if line.startswith(\'$\'):\n                can_add = True\n                continue\n            if line == \'\':\n                can_add = False\n                continue\n            if can_add:\n                filtered.append(line)\n\n        return filtered\n\n    def git_status_file(self, file_name):\n        # first 2 characters are status codes, the third is a space\n        return file_name[3:]\n\n    def svn_status_file(self, file_name):\n        return file_name[8:]\n\n    def bzr_status_file(self, file_name):\n        return file_name[4:]\n\n    def hg_status_file(self, file_name):\n        return file_name[2:]\n\n    def tf_status_file(self, file_name):\n        try:\n            # assume that file name should always contain colon\n            return re.findall(r\'\\s+(\\S+:.+)$\', file_name)[0]\n        except:\n            return None\n\n    def status_done(self, result):\n        filter_status = getattr(self, \'{0}_filter_status\'.format(self.vcs[\'name\']), None)\n\n        self.results = [item.replace(\'\\r\', \'\') for item in filter_status(result)]\n\n        if self.results:\n            self.show_status_list()\n        else:\n            sublime.status_message("Nothing to show")\n\n    def show_status_list(self):\n        options = copy(self.results)\n        options.insert(0, " - Open All")\n        self.get_window().show_quick_panel(options, self.panel_done, sublime.MONOSPACE_FONT)\n\n    def panel_done(self, picked):\n        if picked == 0:\n            self.open_files(*self.results)\n            return\n        elif 0 > picked < len(self.results):\n            return\n        picked_file = self.results[picked - 1]\n        self.open_files(picked_file)\n\n    def open_files(self, *files):\n        for f in files:\n            get_file = getattr(self, \'{0}_status_file\'.format(self.vcs[\'name\']), None)\n            if get_file:\n                fname = get_file(f)\n                if os.path.isfile(os.path.join(self.vcs[\'root\'], fname)):\n                    self.window.open_file(os.path.join(self.vcs[\'root\'], fname))\n                else:\n                    sublime.status_message("File \'{0}\' doesn\'t exist".format(fname))\n\n\nclass ToggleHighlightChangesCommand(sublime_plugin.TextCommand):\n    def run(self, edit):\n        setting_name = "highlight_changes"\n        settings = get_settings()\n        is_on = settings.get(setting_name)\n\n        if is_on:\n            # remove highlighting\n            [self.view.erase_regions(k) for k in (\'inserted\', \'changed\', \'deleted\')]\n        else:\n            self.view.run_command(\'hl_changes\')\n\n        settings.set(setting_name, not is_on)\n        sublime.save_settings("Modific.sublime-settings")\n'program output:b'# -*- coding: utf-8 -*-\n\nfrom __future__ import print_function\n\nimport sublime\nimport sublime_plugin\nimport os\nimport threading\nimport subprocess\nimport functools\nimport re\nfrom copy import copy\n\nIS_ST3 = sublime.version().startswith(\'3\')\n\n\ndef get_settings():\n    return sublime.load_settings("Modific.sublime-settings")\n\n\ndef get_vcs_settings():\n    """\n    Returns list of dictionaries\n    each dict. represents settings for VCS\n    """\n\n    default = [\n        {"name": "git", "dir": ".git", "cmd": "git"},\n        {"name": "svn", "dir": ".svn", "cmd": "svn"},\n        {"name": "bzr", "dir": ".bzr", "cmd": "bzr"},\n        {"name": "hg",  "dir": ".hg",  "cmd": "hg"},\n        {"name": "tf",  "dir": "$tf",  "cmd": "C:/Program Files (x86)/Microsoft Visual Studio 11.0/Common7/IDE/TF.exe"}\n    ]\n    settings = get_settings().get(\'vcs\', default)\n\n    # re-format settings array if user has old format of settings\n    if type(settings[0]) == list:\n        settings = [dict(name=name, cmd=cmd, dir=\'.\'+name) for name, cmd in settings]\n\n    return settings\n\n\ndef get_user_command(vcs_name):\n    """\n    Returns command that user specified for vcs_name\n    """\n\n    try:\n        return [vcs[\'cmd\'] for vcs in get_vcs_settings() if vcs.get(\'name\') == vcs_name][0]\n    except IndexError:\n        return None\n\n\ndef tfs_root(directory):\n    try:\n        tf_cmd = get_user_command(\'tf\') or \'tf\'\n        command = [tf_cmd, \'workfold\', directory]\n        p = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE,\n                             shell=True, universal_newlines=False)\n        out, err = p.communicate()\n        m = re.search(r"^ \\$\\S+: (\\S+)$", out, re.MULTILINE)\n        if m:\n            return {\'root\': m.group(1), \'name\': \'tf\', \'cmd\': tf_cmd}\n    except:\n        return None\n\n\ndef get_vcs(directory):\n    """\n    Determines root directory for VCS and which of VCS systems should be used for a given directory\n\n    Returns dictionary {name: .., root: .., cmd: .., dir: ..}\n    """\n\n    vcs_check = [(lambda vcs: lambda dir: os.path.exists(os.path.join(dir, vcs.get(\'dir\', False)))\n                 and vcs)(vcs) for vcs in get_vcs_settings()]\n\n    start_directory = directory\n    while directory:\n        available = list(filter(bool, [check(directory) for check in vcs_check]))\n        if available:\n            available[0][\'root\'] = directory\n            return available[0]\n\n        parent = os.path.realpath(os.path.join(directory, os.path.pardir))\n        if parent == directory:  # /.. == /\n            # try TFS as a last resort\n            # I\'m not sure why we need to do this. Seems like it should find root for TFS in the main loop\n            return tfs_root(start_directory)\n        directory = parent\n\n    return None\n\n\ndef main_thread(callback, *args, **kwargs):\n    # sublime.set_timeout gets used to send things onto the main thread\n    # most sublime.[something] calls need to be on the main thread\n    sublime.set_timeout(functools.partial(callback, *args, **kwargs), 0)\n\n\ndef _make_text_safeish(text, fallback_encoding, method=\'decode\'):\n    # The unicode decode here is because sublime converts to unicode inside\n    # insert in such a way that unknown characters will cause errors, which is\n    # distinctly non-ideal... and there\'s no way to tell what\'s coming out of\n    # git in output. So...\n    try:\n        unitext = getattr(text, method)(\'utf-8\')\n    except (UnicodeEncodeError, UnicodeDecodeError):\n        unitext = getattr(text, method)(fallback_encoding)\n    except AttributeError:\n        # strongly implies we\'re already unicode, but just in case let\'s cast\n        # to string\n        unitext = str(text)\n    return unitext\n\n\ndef do_when(conditional, callback, *args, **kwargs):\n    if conditional():\n        return callback(*args, **kwargs)\n    sublime.set_timeout(functools.partial(do_when, conditional, callback, *args, **kwargs), 50)\n\n\ndef log(*args, **kwargs):\n    """\n    @param *args: string arguments that should be logged to console\n    @param debug=True: debug log mode\n    @param settings=None: instance of sublime.Settings\n    """\n    debug = kwargs.get(\'debug\', True)\n    settings = kwargs.get(\'settings\', None)\n\n    if not settings:\n        settings = get_settings()\n\n    if debug and not settings.get(\'debug\', False):\n        return\n\n    print(\'Modific:\', *args)\n\n\nclass CommandThread(threading.Thread):\n\n    def __init__(self, command, on_done, working_dir="", fallback_encoding="", console_encoding="", **kwargs):\n        threading.Thread.__init__(self)\n        self.command = command\n        self.on_done = on_done\n        self.working_dir = working_dir\n        if \'stdin\' in kwargs:\n            self.stdin = kwargs[\'stdin\'].encode()\n        else:\n            self.stdin = None\n        self.stdout = kwargs.get(\'stdout\', subprocess.PIPE)\n        self.console_encoding = console_encoding\n        self.fallback_encoding = fallback_encoding\n        self.kwargs = kwargs\n\n    def run(self):\n        try:\n            # Per http://bugs.python.org/issue8557 shell=True is required to\n            # get $PATH on Windows. Yay portable code.\n            shell = os.name == \'nt\'\n\n            if self.working_dir != "":\n                os.chdir(self.working_dir)\n\n            if self.console_encoding:\n                self.command = [s.encode(self.console_encoding) for s in self.command]\n\n            proc = subprocess.Popen(self.command,\n                                    stdout=self.stdout, stderr=subprocess.STDOUT,\n                                    stdin=subprocess.PIPE,\n                                    shell=shell, universal_newlines=False)\n            output = proc.communicate(self.stdin)[0]\n            if not output:\n                output = \'\'\n            # if sublime\'s python gets bumped to 2.7 we can just do:\n            # output = subprocess.check_output(self.command)\n            main_thread(self.on_done,\n                        _make_text_safeish(output, self.fallback_encoding), **self.kwargs)\n        except subprocess.CalledProcessError as e:\n            main_thread(self.on_done, e.returncode)\n        except OSError as e:\n            if e.errno == 2:\n                main_thread(sublime.error_message,\n                            "\'%s\' binary could not be found in PATH\\n\\nConsider using `vcs` property to specify PATH\\n\\nPATH is: %s" % (self.command[0], os.environ[\'PATH\']))\n            else:\n                raise e\n\n\nclass EditViewCommand(sublime_plugin.TextCommand):\n\n    def run(self, edit, command=None, output=\'\', begin=0, region=None):\n        """\n        For some reason Sublime\'s view.run_command() doesn\'t allow to pass tuples,\n        therefore region must be a list\n        """\n        region = sublime.Region(int(region[0]), int(region[1])) if region else None\n        if command == \'insert\':\n            self.view.insert(edit, int(begin), output)\n        elif command == \'replace\':\n            self.view.replace(edit, region, output)\n        elif command == \'erase\':\n            self.view.erase(edit, region)\n        else:\n            print(\'Invalid command: \', command)\n            raise\n\n\nclass VcsCommand(object):\n    may_change_files = False\n\n    def __init__(self, *args, **kwargs):\n        self.settings = get_settings()\n        super(VcsCommand, self).__init__(*args, **kwargs)\n\n    def log(self, *args, **kwargs):\n        return log(settings=self.settings, *args, **kwargs)\n\n    def run_command(self, command, callback=None, show_status=False,\n                    filter_empty_args=True, **kwargs):\n        if filter_empty_args:\n            command = [arg for arg in command if arg]\n        if \'working_dir\' not in kwargs:\n            kwargs[\'working_dir\'] = self.get_working_dir()\n        if \'fallback_encoding\' not in kwargs and self.active_view() and self.active_view().settings().get(\'fallback_encoding\'):\n            kwargs[\'fallback_encoding\'] = self.active_view().settings().get(\'fallback_encoding\').rpartition(\'(\')[2].rpartition(\')\')[0]\n        kwargs[\'console_encoding\'] = self.settings.get(\'console_encoding\')\n\n        autosave = self.settings.get(\'autosave\', True)\n        if self.active_view() and self.active_view().is_dirty() and autosave:\n            self.active_view().run_command(\'save\')\n        if not callback:\n            callback = self.generic_done\n\n        log(\'run command:\', \' \'.join(command))\n        thread = CommandThread(command, callback, **kwargs)\n        thread.start()\n\n        if show_status:\n            message = kwargs.get(\'status_message\', False) or \' \'.join(command)\n            sublime.status_message(message + \'wef\')\n\n    def generic_done(self, result):\n        self.log(\'generic_done\', result)\n        if self.may_change_files and self.active_view() and self.active_view().file_name():\n            if self.active_view().is_dirty():\n                result = "WARNING: Current view is dirty.\\n\\n"\n            else:\n                # just asking the current file to be re-opened doesn\'t do anything\n                print("reverting")\n                position = self.active_view().viewport_position()\n                self.active_view().run_command(\'revert\')\n                do_when(lambda: not self.active_view().is_loading(),\n                        lambda: self.active_view().set_viewport_position(position, False))\n\n        if not result.strip():\n            return\n        self.panel(result)\n\n    def _output_to_view(self, output_file, output, clear=False,\n                        syntax="Packages/Diff/Diff.tmLanguage"):\n        output_file.set_syntax_file(syntax)\n        if clear:\n            output_file.run_command(\'edit_view\', dict(command=\'replace\', region=[0, self.output_view.size()], output=output))\n        else:\n            output_file.run_command(\'edit_view\', dict(command=\'insert\', output=output))\n\n    def scratch(self, output, title=False, position=None, **kwargs):\n        scratch_file = self.get_window().new_file()\n        if title:\n            scratch_file.set_name(title)\n        scratch_file.set_scratch(True)\n        self._output_to_view(scratch_file, output, **kwargs)\n        scratch_file.set_read_only(True)\n        if position:\n            sublime.set_timeout(lambda: scratch_file.set_viewport_position(position), 0)\n        return scratch_file\n\n    def panel(self, output, **kwargs):\n        if not hasattr(self, \'output_view\'):\n            self.output_view = self.get_window().get_output_panel("vcs")\n        self.output_view.set_read_only(False)\n        self._output_to_view(self.output_view, output, clear=True, **kwargs)\n        self.output_view.set_read_only(True)\n        self.get_window().run_command("show_panel", {"panel": "output.vcs"})\n\n    def _active_file_name(self):\n        view = self.active_view()\n        if view and view.file_name() and len(view.file_name()) > 0:\n            return view.file_name()\n\n    def active_view(self):\n        return self.view\n\n    def get_window(self):\n        if (hasattr(self, \'view\') and hasattr(self.view, \'window\')):\n            return self.view.window()\n        else:\n            return sublime.active_window()\n\n    def get_working_dir(self):\n        return os.path.dirname(self._active_file_name())\n\n    def is_enabled(self):\n        file_name = self._active_file_name()\n        if file_name and os.path.exists(file_name):\n            return bool(get_vcs(self.get_working_dir()))\n        return False\n\n\nclass DiffCommand(VcsCommand):\n    """ Here you can define diff commands for your VCS\n        method name pattern: %(vcs_name)s_diff_command\n    """\n\n    def run(self, edit):\n        vcs = get_vcs(self.get_working_dir())\n        filepath = self.view.file_name()\n        filename = os.path.basename(filepath)\n        max_file_size = self.settings.get(\'max_file_size\', 1024) * 1024\n        if not os.path.exists(filepath) or os.path.getsize(filepath) > max_file_size:\n            # skip large files\n            return\n        get_command = getattr(self, \'{0}_diff_command\'.format(vcs[\'name\']), None)\n        if get_command:\n            self.run_command(get_command(filename), self.diff_done)\n\n    def diff_done(self, result):\n        self.log(\'diff_done\', result)\n\n    def git_diff_command(self, file_name):\n        vcs_options = self.settings.get(\'vcs_options\', {}).get(\'git\') or [\'--no-color\', \'--no-ext-diff\']\n        return [get_user_command(\'git\') or \'git\', \'diff\'] + vcs_options + [\'--\', file_name]\n\n    def svn_diff_command(self, file_name):\n        params = [get_user_command(\'svn\') or \'svn\', \'diff\']\n        params.extend(self.settings.get(\'vcs_options\', {}).get(\'svn\', []))\n\n        if \'--internal-diff\' not in params and self.settings.get(\'svn_use_internal_diff\', True):\n            params.append(\'--internal-diff\')\n\n        # if file starts with @, use `--revision HEAD` option\n        # https://github.com/gornostal/Modific/issues/17\n        if file_name.find(\'@\') != -1:\n            file_name += \'@\'\n            params.extend([\'--revision\', \'HEAD\'])\n\n        params.append(file_name)\n        return params\n\n    def bzr_diff_command(self, file_name):\n        vcs_options = self.settings.get(\'vcs_options\', {}).get(\'bzr\', [])\n        return [get_user_command(\'bzr\') or \'bzr\', \'diff\'] + vcs_options + [file_name]\n\n    def hg_diff_command(self, file_name):\n        vcs_options = self.settings.get(\'vcs_options\', {}).get(\'hg\', [])\n        return [get_user_command(\'hg\') or \'hg\', \'diff\'] + vcs_options + [file_name]\n\n    def tf_diff_command(self, file_name):\n        vcs_options = self.settings.get(\'vcs_options\', {}).get(\'tf\') or [\'-format:unified\']\n        return [get_user_command(\'tf\') or \'tf\', \'diff\'] + vcs_options + [file_name]\n\n    def get_line_ending(self):\n        return \'\\n\'\n\n    def join_lines(self, lines):\n        """\n        Join lines using os.linesep.join(), unless another method is specified in ST settings\n        """\n        return self.get_line_ending().join(lines)\n\n\nclass ShowDiffCommand(DiffCommand, sublime_plugin.TextCommand):\n    def diff_done(self, result):\n        self.log(\'on show_diff\', result)\n\n        if not result.strip():\n            return\n\n        result = result.replace(\'\\r\\n\', \'\\n\')\n        file_name = re.findall(r\'([^\\\\\\/]+)$\', self.view.file_name())\n        self.scratch(result, title="Diff - " + file_name[0])\n\n\nclass DiffParser(object):\n    instance = None\n\n    def __init__(self, diff):\n        self.diff = diff\n        self.chunks = None\n        self.__class__.instance = self\n\n    def _append_to_chunks(self, start, lines):\n        self.chunks.append({\n            "start": start,\n            "end": start + len(lines),\n            "lines": lines\n        })\n\n    def get_chunks(self):\n        if self.chunks is None:\n            self.chunks = []\n            diff = self.diff.strip()\n            if diff:\n                re_header = re.compile(r\'^@@[0-9\\-, ]+\\+(\\d+)\', re.S)\n                current = None\n                lines = []\n                for line in diff.splitlines():\n                    # ignore lines with \'\\\' at the beginning\n                    if line.startswith(\'\\\\\'):\n                        continue\n\n                    matches = re.findall(re_header, line)\n                    if matches:\n                        if current is not None:\n                            self._append_to_chunks(current, lines)\n                        current = int(matches[0])\n                        lines = []\n                    elif current:\n                        lines.append(line)\n                if current is not None and lines:\n                    self._append_to_chunks(current, lines)\n\n        return self.chunks\n\n    def get_lines_to_hl(self):\n        inserted = []\n        changed = []\n        deleted = []\n\n        for chunk in self.get_chunks():\n            current = chunk[\'start\']\n            deleted_line = None\n            for line in chunk[\'lines\']:\n                if line.startswith(\'-\'):\n                    if (not deleted_line or deleted_line not in deleted):\n                        deleted.append(current)\n                    deleted_line = current\n                elif line.startswith(\'+\'):\n                    if deleted_line:\n                        deleted.pop()\n                        deleted_line = None\n                        changed.append(current)\n                    elif current - 1 in changed:\n                        changed.append(current)\n                    else:\n                        inserted.append(current)\n                    current += 1\n                else:\n                    deleted_line = None\n                    current += 1\n\n        return inserted, changed, deleted\n\n    def get_original_part(self, line_num):\n        """ returns a chunk of code that relates to the given line\n            and was there before modifications\n\n            return (lines list, start_line int, replace_lines int)\n        """\n\n        # for each chunk from diff:\n        for chunk in self.get_chunks():\n            # if line_num is within that chunk\n            if chunk[\'start\'] <= line_num <= chunk[\'end\']:\n                ret_lines = []\n                current = chunk[\'start\']  # line number that corresponds to current version of file\n                first = None  # number of the first line to change\n                replace_lines = 0  # number of lines to change\n                return_this_lines = False  # flag shows whether we can return accumulated lines\n                for line in chunk[\'lines\']:\n                    if line.startswith(\'-\') or line.startswith(\'+\'):\n                        first = first or current\n                        if current == line_num:\n                            return_this_lines = True\n                        if line.startswith(\'-\'):\n                            # if line starts with \'-\' we have previous version\n                            ret_lines.append(line[1:])\n                        else:\n                            # if line starts with \'+\' we only increment numbers\n                            replace_lines += 1\n                            current += 1\n                    elif return_this_lines:\n                        break\n                    else:\n                        # gap between modifications\n                        # reset our variables\n                        current += 1\n                        first = current\n                        replace_lines = 0\n                        ret_lines = []\n                if return_this_lines:\n                    return ret_lines, first, replace_lines\n\n        return None, None, None\n\n\nclass HlChangesCommand(DiffCommand, sublime_plugin.TextCommand):\n    def hl_lines(self, lines, hl_key):\n        if (not len(lines) or not self.settings.get(\'highlight_changes\')):\n            self.view.erase_regions(hl_key)\n            return\n\n        icon = self.settings.get(\'region_icon\') or \'modific\'\n        if icon == \'modific\':\n            if IS_ST3:\n                icon = \'Packages/Modific/icons/\' + hl_key + \'.png\'\n            else:\n                icon = \'../Modific/icons/\' + hl_key\n        points = [self.view.text_point(l - 1, 0) for l in lines]\n        regions = [sublime.Region(p, p) for p in points]\n        self.view.add_regions(hl_key, regions, "markup.%s.diff" % hl_key, icon, sublime.HIDDEN | sublime.DRAW_EMPTY)\n\n    def diff_done(self, diff):\n        self.log(\'on hl_changes:\', diff)\n\n        if diff and \'@@\' not in diff:\n            # probably this is an error message\n            # if print raise UnicodeEncodeError, try to encode string to utf-8 (issue #35)\n            try:\n                print(diff)\n            except UnicodeEncodeError:\n                print(diff.encode(\'utf-8\'))\n\n        diff_parser = DiffParser(diff)\n        (inserted, changed, deleted) = diff_parser.get_lines_to_hl()\n\n        self.log(\'new lines:\', inserted)\n        self.log(\'modified lines:\', changed)\n        self.log(\'deleted lines:\', deleted)\n\n        self.hl_lines(inserted, \'inserted\')\n        self.hl_lines(deleted, \'deleted\')\n        self.hl_lines(changed, \'changed\')\n\n\nclass ShowOriginalPartCommand(DiffCommand, sublime_plugin.TextCommand):\n    def run(self, edit):\n        diff_parser = DiffParser.instance\n        if not diff_parser:\n            return\n\n        (row, col) = self.view.rowcol(self.view.sel()[0].begin())\n        (lines, start, replace_lines) = diff_parser.get_original_part(row + 1)\n        if lines is not None:\n            self.panel(self.join_lines(lines))\n\n\nclass ReplaceModifiedPartCommand(DiffCommand, sublime_plugin.TextCommand):\n    def run(self, edit):\n        self.view.run_command(\'save\')\n\n        diff_parser = DiffParser.instance\n        if not diff_parser:\n            return\n\n        (row, col) = self.view.rowcol(self.view.sel()[0].begin())\n        (lines, current, replace_lines) = diff_parser.get_original_part(row + 1)\n        if self.settings.get(\'debug\'):\n            print(\'replace\', (lines, current, replace_lines))\n        if lines is not None:\n            begin = self.view.text_point(current - 1, 0)\n            content = self.join_lines(lines)\n            if replace_lines:\n                end = self.view.line(self.view.text_point(replace_lines + current - 2, 0)).end()\n                region = sublime.Region(begin, end)\n                if lines:\n                    self.view.run_command(\'edit_view\', dict(command=\'replace\', region=[region.begin(), region.end()], output=content))\n                else:\n                    region = self.view.full_line(region)\n                    self.view.run_command(\'edit_view\', dict(command=\'erase\', region=[region.begin(), region.end()]))\n            else:\n                self.view.run_command(\'edit_view\', dict(command=\'insert\', begin=begin,\n                                                        output=content + self.get_line_ending()))\n            self.view.run_command(\'save\')\n\n\nclass HlChangesBackground(sublime_plugin.EventListener):\n    def on_load(self, view):\n        if not IS_ST3:\n            view.run_command(\'hl_changes\')\n\n    def on_load_async(self, view):\n        view.run_command(\'hl_changes\')\n\n    def on_activated(self, view):\n        if not IS_ST3:\n            view.run_command(\'hl_changes\')\n\n    def on_activated_async(self, view):\n        view.run_command(\'hl_changes\')\n\n    def on_post_save(self, view):\n        if not IS_ST3:\n            view.run_command(\'hl_changes\')\n\n    def on_post_save_async(self, view):\n        view.run_command(\'hl_changes\')\n\n\nclass JumpBetweenChangesCommand(DiffCommand, sublime_plugin.TextCommand):\n    def run(self, edit, direction=\'next\'):\n        lines = self._get_lines()\n        if not lines:\n            return\n\n        if direction == \'prev\':\n            lines.reverse()\n\n        (current_line, col) = self.view.rowcol(self.view.sel()[0].begin())\n        current_line += 1\n        jump_to = None\n        for line in lines:\n            if direction == \'next\' and current_line < line:\n                jump_to = line\n                break\n            if direction == \'prev\' and current_line > line:\n                jump_to = line\n                break\n\n        if not jump_to:\n            jump_to = lines[0]\n\n        self.goto_line(edit, jump_to)\n\n    def goto_line(self, edit, line):\n        # Convert from 1 based to a 0 based line number\n        line = int(line) - 1\n\n        # Negative line numbers count from the end of the buffer\n        if line < 0:\n            lines, _ = self.view.rowcol(self.view.size())\n            line = lines + line + 1\n\n        pt = self.view.text_point(line, 0)\n\n        self.view.sel().clear()\n        self.view.sel().add(sublime.Region(pt))\n\n        self.view.show(pt)\n\n    def _get_lines(self):\n        diff_parser = DiffParser.instance\n        if not diff_parser:\n            return\n\n        (inserted, changed, deleted) = diff_parser.get_lines_to_hl()\n        lines = list(set(inserted + changed + deleted))\n        lines.sort()\n\n        prev = None\n        ret_lines = []\n        for line in lines:\n            if prev != line - 1:\n                ret_lines.append(line)\n            prev = line\n\n        return ret_lines\n\n\nclass UncommittedFilesCommand(VcsCommand, sublime_plugin.WindowCommand):\n    def active_view(self):\n        return self.window.active_view()\n\n    def is_enabled(self):\n        return bool(self.get_working_dir())\n\n    def get_working_dir(self):\n        if self._active_file_name():\n            working_dir = super(UncommittedFilesCommand, self).get_working_dir()\n            if working_dir and get_vcs(working_dir):\n                return working_dir\n\n        # If the user has opened a vcs folder, use it.\n        folders = self.window.folders()\n        for folder in folders:\n            if folder and os.path.exists(folder) and get_vcs(folder):\n                return folder\n\n    def run(self):\n        self.vcs = get_vcs(self.get_working_dir())\n        status_command = getattr(self, \'{0}_status_command\'.format(self.vcs[\'name\']), None)\n        if status_command:\n            self.run_command(status_command(), self.status_done, working_dir=self.vcs[\'root\'])\n\n    def git_status_command(self):\n        return [get_user_command(\'git\') or \'git\', \'status\', \'--porcelain\']\n\n    def svn_status_command(self):\n        return [get_user_command(\'svn\') or \'svn\', \'status\', \'--quiet\']\n\n    def bzr_status_command(self):\n        return [get_user_command(\'bzr\') or \'bzr\', \'status\', \'-S\', \'--no-pending\', \'-V\']\n\n    def hg_status_command(self):\n        return [get_user_command(\'hg\') or \'hg\', \'status\']\n\n    def tf_status_command(self):\n        return [get_user_command(\'tf\') or \'tf\', \'status\']\n\n    def filter_unified_status(self, result):\n        return list(filter(lambda x: len(x) > 0 and not x.lstrip().startswith(\'>\'),\n                    result.rstrip().split(\'\\n\')))\n\n    def git_filter_status(self, result):\n        return self.filter_unified_status(result)\n\n    def svn_filter_status(self, result):\n        return self.filter_unified_status(result)\n\n    def bzr_filter_status(self, result):\n        return self.filter_unified_status(result)\n\n    def hg_filter_status(self, result):\n        return self.filter_unified_status(result)\n\n    def tf_filter_status(self, result):\n        filtered = []\n        can_add = False\n        for line in result.split(\'\\n\'):\n            if line.startswith(\'$\'):\n                can_add = True\n                continue\n            if line == \'\':\n                can_add = False\n                continue\n            if can_add:\n                filtered.append(line)\n\n        return filtered\n\n    def git_status_file(self, file_name):\n        # first 2 characters are status codes, the third is a space\n        return file_name[3:]\n\n    def svn_status_file(self, file_name):\n        return file_name[8:]\n\n    def bzr_status_file(self, file_name):\n        return file_name[4:]\n\n    def hg_status_file(self, file_name):\n        return file_name[2:]\n\n    def tf_status_file(self, file_name):\n        try:\n            # assume that file name should always contain colon\n            return re.findall(r\'\\s+(\\S+:.+)$\', file_name)[0]\n        except:\n            return None\n\n    def status_done(self, result):\n        filter_status = getattr(self, \'{0}_filter_status\'.format(self.vcs[\'name\']), None)\n\n        self.results = [item.replace(\'\\r\', \'\') for item in filter_status(result)]\n\n        if self.results:\n            self.show_status_list()\n        else:\n            sublime.status_message("Nothing to show")\n\n    def show_status_list(self):\n        options = copy(self.results)\n        options.insert(0, " - Open All")\n        self.get_window().show_quick_panel(options, self.panel_done, sublime.MONOSPACE_FONT)\n\n    def panel_done(self, picked):\n        if picked == 0:\n            self.open_files(*self.results)\n            return\n        elif 0 > picked < len(self.results):\n            return\n        picked_file = self.results[picked - 1]\n        self.open_files(picked_file)\n\n    def open_files(self, *files):\n        for f in files:\n            get_file = getattr(self, \'{0}_status_file\'.format(self.vcs[\'name\']), None)\n            if get_file:\n                fname = get_file(f)\n                if os.path.isfile(os.path.join(self.vcs[\'root\'], fname)):\n                    self.window.open_file(os.path.join(self.vcs[\'root\'], fname))\n                else:\n                    sublime.status_message("File \'{0}\' doesn\'t exist".format(fname))\n\n\nclass ToggleHighlightChangesCommand(sublime_plugin.TextCommand):\n    def run(self, edit):\n        setting_name = "highlight_changes"\n        settings = get_settings()\n        is_on = settings.get(setting_name)\n\n        if is_on:\n            # remove highlighting\n            [self.view.erase_regions(k) for k in (\'inserted\', \'changed\', \'deleted\')]\n        else:\n            self.view.run_command(\'hl_changes\')\n\n        settings.set(setting_name, not is_on)\n        sublime.save_settings("Modific.sublime-settings")\n'